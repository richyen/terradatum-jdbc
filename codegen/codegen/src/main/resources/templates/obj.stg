import "types.stg"

properties(attributeInfo) ::= <<
private <attributeInfo:parameters()>;

>>

parameters(attributeInfo) ::= <%
<if(attributeInfo.struct||attributeInfo.array)><attributeInfo:paramComposite()>
<else><javaTypeNameMap.(attributeInfo.typeName)> <attributeInfo.propertyName>
<endif>
%>

paramComposite(attributeInfo) ::= <%
<if(attributeInfo.differentSchema)><package>.<attributeInfo.schemaName>.<attributeInfo.className> <attributeInfo.propertyName>
<else><attributeInfo.className> <attributeInfo.propertyName>
<endif>
%>

setAttributes(attributeInfo, index) ::= <%
<if(attributeInfo.struct)><setStructAttribute(attributeInfo=attributeInfo, index=index)>
<elseif(attributeInfo.array)><setArrayAttribute(attributeInfo=attributeInfo, index=index)>
<else><setAttribute(attributeInfo=attributeInfo, index=index)>
<endif>;
%>

setStructAttribute(attributeInfo, index) ::= <<

<if(attributeInfo.differentSchema)><attributeInfo.propertyName> = new <package>.<attributeInfo.schemaName>.<attributeInfo.className>();
<attributeInfo.propertyName>.setStruct((Struct) attributes[<index>])<else><attributeInfo.propertyName> = new <attributeInfo.className>();
<attributeInfo.propertyName>.setStruct((Struct) attributes[<index>])<endif>
>>

setArrayAttribute(attributeInfo, index) ::= <<

<if(attributeInfo.differentSchema)><attributeInfo.propertyName> = new <package>.<attributeInfo.schemaName>.<attributeInfo.className>();
<attributeInfo.propertyName>.setArray((Array) attributes[<index>])<else><attributeInfo.propertyName> = new <attributeInfo.className>();
<attributeInfo.propertyName>.setArray((Array) attributes[<index>])<endif>
>>

setAttribute(attributeInfo, index) ::= <<

<attributeInfo.propertyName> = ConverterUtil.convert(attributes[<index>], <javaTypeNameMap.(attributeInfo.typeName)>.class)
>>

getSet(attributeInfo) ::= <%
<if(attributeInfo.struct||attributeInfo.array)><attributeInfo:getSetComposite()>
<else><attributeInfo:getSetType()>
<endif>
%>

getSetType(attributeInfo) ::= <<

public <javaTypeNameMap.(attributeInfo.typeName)> get<attributeInfo.accessorName>() {
	return <attributeInfo.propertyName>;
}

public void set<attributeInfo.accessorName>(<javaTypeNameMap.(attributeInfo.typeName)> <attributeInfo.propertyName>) {
	this.<attributeInfo.propertyName> = <attributeInfo.propertyName>;
}

>>

getSetComposite(attributeInfo) ::= <<

public <if(attributeInfo.differentSchema)><package>.<attributeInfo.schemaName>.<attributeInfo.className><else><attributeInfo.className><endif> get<attributeInfo.accessorName>() {
	return <attributeInfo.propertyName>;
}

public void set<attributeInfo.accessorName>(<if(attributeInfo.differentSchema)><package>.<attributeInfo.schemaName>.<attributeInfo.className><else><attributeInfo.className><endif> <attributeInfo.propertyName>) {
	this.<attributeInfo.propertyName> = <attributeInfo.propertyName>;
}

>>

equals(attributeInfo) ::= <<

Objects.equals(get<attributeInfo.accessorName>(), that.get<attributeInfo.accessorName>()) &&
>>

lastEquals(attributeInfo) ::= <<
Objects.equals(get<attributeInfo.accessorName>(), that.get<attributeInfo.accessorName>());
>>

hashCode(attributeInfo) ::= <<

get<attributeInfo.accessorName>(),
>>

lastHashCode(attributeInfo) ::= <<
get<attributeInfo.accessorName>());
>>

toString(attributeInfo) ::= <<

.add("<attributeInfo.propertyName>", get<attributeInfo.accessorName>())
>>

lastToString(attributeInfo) ::= <<
.add("<attributeInfo.propertyName>", get<attributeInfo.accessorName>()).toString();
>>

main(typeInfo,package,created) ::= <<
package <package>.<typeInfo.schemaName>;

import com.terradatum.jdbc.converters.ConverterUtil;
import com.terradatum.jdbc.DbStruct;
import com.google.common.base.MoreObjects;

import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.sql.Array;
import java.sql.SQLException;
import java.sql.Struct;
import java.sql.Timestamp;
import java.util.Map;
import java.util.Objects;

/**
 * DO NOT MODIFY!!! This class was generated by the Terradatum JDBC Code Generator and will be overwritten if regenerated
 * @date <created>
 */
public class <typeInfo.className> implements DbStruct {
	public static final String SQL_TYPE_NAME = "<typeInfo.typeName>";

	<typeInfo.attributeInfos:properties()>
	/**
	 * Required default constructor.
	 */
	@SuppressWarnings("unused")
	public <typeInfo.className>() {
	}

		/**
		 * All-elements, type-safe constructor
		 */
	@SuppressWarnings("unused")
	public <typeInfo.className>(<typeInfo.attributeInfos:parameters(); separator=", ">) {
		<typeInfo.attributeInfos:{attributeInfo |this.<attributeInfo.propertyName> = <attributeInfo.propertyName>;
		}>
	}

	/**
	 * Set the {@link Struct}, which is then parsed and hydrated into the properties of the {@link DbStruct}.
	 *
	 * There are numerous casts and other shenanigans occurring here, so this method can throw numerous exceptions.
	 * This is a better solution than a method that hides all exceptions and prevents the call site from responding
	 * accordingly.
	 * @param struct the {@link java.sql.Struct} which is used as the model for this {@link DbStruct} object
	 * @throws SQLException
	 * @throws NoSuchMethodException
	 * @throws NoSuchFieldException
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 */
	@SuppressWarnings("unused")
	public void setStruct(Struct struct) throws SQLException, NoSuchMethodException, NoSuchFieldException,
						IllegalAccessException, InvocationTargetException {
		if (struct != null) {
			setAttributes(struct.getAttributes());
		}
	}

	@Override
	public String getSQLTypeName() throws SQLException {
		return SQL_TYPE_NAME;
	}

	@Override
	public Object[] getAttributes() throws SQLException {
		return new Object[]{<typeInfo.attributeInfos:{attributeInfo |<attributeInfo.propertyName>}; separator=", ">};
	}

	@Override
	public Object[] getAttributes(Map\<String, Class\<?>\> map) throws SQLException { <! weird parse error outputs escape character with the character to be escaped !>
		return getAttributes();
	}

	@Override
	public void setAttributes(Object[] attributes) throws SQLException, InvocationTargetException,
						NoSuchMethodException, IllegalAccessException, NoSuchFieldException {
		<typeInfo.attributeInfos:{attributeInfo | <setAttributes(attributeInfo=attributeInfo, index=i0)>}>
	}

	<typeInfo.attributeInfos:getSet()

		>
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}

		<typeInfo.className> that = (<typeInfo.className>) o;
		return
			<trunc(typeInfo.attributeInfos):equals()>
			<last(typeInfo.attributeInfos):lastEquals()>
	}

	@Override
	public int hashCode() {
		return Objects.hash(
				<trunc(typeInfo.attributeInfos):hashCode()>
				<last(typeInfo.attributeInfos):lastHashCode()>
	}

	@Override
	public String toString() {
		return MoreObjects.toStringHelper(this)
				<trunc(typeInfo.attributeInfos):toString()>
				<last(typeInfo.attributeInfos):lastToString()>
	}
}
>>