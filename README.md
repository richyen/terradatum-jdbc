Terradatum JDBC for ORDBMS
==========================

Why another data access abstraction?

This project was born of the question: how can I run an application targeting both PPAS and Oracle?

PPAS has remarkable feature parity at the database, with support for PG/SQL partitioning language (as opposed to the PostgreSQL
rules-based partitioning), packages and collection Object-Relational (ORDBMS) types, to name a few of the items of greatest
interest to us. What options do you have if, for better of worse, you make heavy use of in-database ORDBMS types (`OBJECT` and
`TABLE` types)?

The EnterpriseDB (EDB) JDBC drivers do not offer the same level of support as OJDBC, making it a challenge when trying to write
code that will work with both PPAS and Oracle ORDBMS constructs.

The tools usually used to abstract away the differences between PPAS and Oracle all require non-trivial effort - in every case
requiring almost the same amount of effort as that required to add a completely new database to their list of supported RDBMS'.

The Landscape
-------------

### Oracle ORDBMS and the OJDBC extensions
When working with Oracle ORDBMS types, the OJDBC extensions offer an out-of-the-box code generator, JPublisher, which can
basically produce two types of output: Oracle-proprietary and JDBC.

1. The Oracle output creates both `OBJECT` and `TABLE` representations in Java, where the `oracle.jdbc.STRUCT` types provide
strongly-typed POJOs with accessors and mutators, and the `oracle.jdbc.ARRAY` types offer strongly-typed collection semantics.
Both are implementations of the `ORAData` and `ORADataFactory` interfaces and offer all the plumbing necessary to work closely
with the OJDBC extensions - like sending and receiving object and collection types as input and output parameters for functions
and procedures.
2. The JDBC output creates Java representations based on the JDBC `SQLData` interface and the `SQLInput` and `SQLOutput` streams.
There are no collection types, per-se, though the support for `SQLMap`'s allows the developer to get very close to the same
functionality found in the Oracle-specific JDBC extensions. The `SQLData` interface implementations generated by JPublisher (or
created by hand) give the user strongly-typed POJOs too - and the plumbing necessary to deal with collection types is minimal.

If you are working with code based on option #1 above, your codebase will be tightly coupled with the "Oracle way" of
accessing ORDBMS types, making heavy use of the `ORAData` and `ORADataFactor` interfaces and calling directly into and out of the
OJDBC API. Any attempt to leverage JPA needs to have a low barrier to entry, as you will have to refactor your data access
layer to use JPA in the first place. Having to build a large contribution to a JPA provider just to get to the point where you
could _start_ integrating JPA into your middle-tier will likely be cost prohibitive.

Option #2 isn't going to work for you with the EDB JDBC drivers either - while the `SQLData` interface is a part of the JDBC
version 4 specification, neither the PGJDBC nor EDB JDBC drivers support it. You *MUST* use what is known as the "weak" reference
APIs - namely `java.sql.Struct` (e.g. [`Connection#createStruct`][1]) and `java.sql.Array` (e.g. [`Connection#createArrayOf`][2]).

### JPA + Provider
[EclipseLink][3] has support for Oracle-specific constructs like [Struct][4], [PLSQL Table types][5] and [Named PLSQL
Functions][6] to name just a few. However, these extensions _will not work_ with the EDB JDBC drivers because they rely
exclusively on the Oracle JDBC driver extensions.

Both EclipseLink and [NHibernate][7] are extensible enough that it is possible to add a "[dialect][8]" for PPAS that would allow
these providers to translate their internals to the "PPAS way". However, JPA itself doesn't do well with ORDBMS types - hence the
need for the EclipseLink extensions. After thoroughly reviewing the EclipseLink codebase it was clear that attempting to leverage
the work already done to support ORDBMS objects in Oracle _could_ be done for PPAS in EclipseLink, however that work would take
significant effort. With NHibernate it would be even more work.

JPA has the concept of a "Native Query" which could be used to call into either PPAS or Oracle. The question still remains how
the data would be hydrated into and out of a model.

In the end, the problem comes down to the fact that PPAS just doesn't have the visibility as other RDBMS's, so all the effort that
has been put into making JPA work with PostgreSQL, for instance, is useful only in that you can use that same functionality in
PPAS. Any additional functionality you may be looking to access in PPAS, like packages or collection types, isn't supported.

### Spring JdbcTemplate and jOOQ
While [Spring's JdbcTemplate][9] and [jOOQ][10] are a better fit than JPA because their API's run "closer to the metal" of the JDBC API,
neither has an implementation that supports those features offered by PPAS that are divergent from PostgreSQL. Again, much work
would need to be done to add functionality to both in order to support the needs of an application that requires the ORDBMS
abilities of PPAS.

The Solution
------------

### Requirements
1. Strongly typed POJOs.
2. Strongly typed collections.
3. Ability to work with functions and procedures such that objects can be used as both IN and OUT parameters.
4. Single API for both PPAS and Oracle.
5. Closely aligned API which mimics the JDBC API as closely as possible.

### Implementation

#### API

The API uses the adapter and decorator patterns to provide a fully-functional JDBC API, delegating client calls into the
underlying connection. When working with `OBJECT` or `TABLE` Java representations, the API expects those representations to implement or extend
a custom interface or class:
* DbStruct - an extension to the `java.sql.Struct` JDBC interface that supports hydrating and dehydrating objects. The challenge
here is that the JDBC `Struct` type is essentially a read-only interface, where the caller is expected to use an instance of the
JDBC `java.sql.Connection` to `createArrayOf` or via one of the calls that retrieves the data from the database and hydrates the
`Struct` before the caller accesses it. With

[1]: https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html#createStruct(java.lang.String,%20java.lang.Object[])
[2]: https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html#createArrayOf(java.lang.String,%20java.lang.Object[])
[3]: http://www.eclipse.org/eclipselink/documentation/
[4]: http://www.eclipse.org/eclipselink/documentation/2.6/jpa/extensions/annotations_ref.htm#CBBDCAHG
[5]: http://www.eclipse.org/eclipselink/documentation/2.6/jpa/extensions/annotations_ref.htm#CACJBHHF
[6]: http://www.eclipse.org/eclipselink/documentation/2.6/jpa/extensions/annotations_ref.htm#BGBDHGJE
[7]: http://nhibernate.info/doc/index.html
[8]: https://github.com/nhibernate/nhibernate-core/tree/master/src/NHibernate/Dialect
[9]: http://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html
[10]: http://jooq.org